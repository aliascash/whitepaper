\section{The Proof of Stake Kernel Hash}

\underline{The kernel hash specifically consists of the following exact pieces of data (in order):}

\begin{itemize}
    \item Previous block's "stake modifier" (more detail on this later)
    \item Timestamp from "prevout" transaction (the transaction output that 
    is spent by the first VIN of the staking transaction)
    \item The hash of the prevout transaction
    \item The output number of the prevout (ie, which output of the 
    transaction is spent by the staking transaction)
    \item Current block time, with the bottom 4 bits set to 0 to reduce 
    granularity. This is the only thing that changes during staking process
\end{itemize}



\underline{The stake modifier of a block is a hash of exactly:}
\begin{itemize}
    \item The hash of the prevout transaction in PoS blocks, OR the block 
    hash in PoW blocks.
    \item The previous block's stake modifier (the genesis block's stake 
    modifier is 0)
\end{itemize}



The only way to change the current kernel hash (in order to mine a block), 
is thus to either change your "\textit{prevout}", or to change the current 
block time.



A single wallet typically contains many UTXOs. The balance of the wallet is 
basically the total amount of all the UTXOs that can be spent by the wallet. 
This is of course the same in a PoS wallet. This is important though, because 
any output can be used for staking. One of these outputs are what can become 
the "\textit{prevout}" in a staking transaction to form a valid PoS block.



Finally, there is one more aspect that is changed in the mining process of a 
PoS block. The difficulty is weighted against the number of coins in the 
staking transaction. The PoS difficulty ends up being twice as easy to achieve 
when staking 2 coins, compared to staking just 1 coin.



If this were not the case, then it would encourage creating many tiny UTXOs 
for staking, which would bloat the size of the blockchain and ultimately 
cause the entire network to require more resources to maintain, as well as 
potentially compromise the blockchain's overall security.



So, if we were to show some pseudo-code for finding a valid kernel hash now, 
it would look like:



...



This code isn't so easy to understand as our PoW example, so I'll attempt to 
explain it in plain English:



Do the following over and over for infinity:
Calculate the blockTime to be the current time minus itself modulus 16
(modulus is like dividing by 16, but then only instead of taking the
result, taking the remainder)
Calculate the posDifficulty as the network difficulty, multiplied by the
number of coins held by the UTXO.
Cycle through each UTXO in the wallet. With each UTXO, calculate a SHA256
hash using the previous block's stake modifier, as well as some data from
the the UTXO, and finally the blockTime. Compare this hash to the
posDifficulty. If the hash is less than the posDifficulty, then the kernel
hash is valid and you can create a new block.
After going through all UTXOs, if no hash produced is less than the
posDifficulty, then wait 16 seconds and do it all over again.



Now that we have found a valid kernel hash using one of the UTXOs we can 
spend, we can create a staking transaction. This staking transaction will 
have 1 VIN, which spends the UTXO we found that has a valid kernel hash. 
It will have (\textit{at least}) 2 VOUTs. The first VOUT will be empty, 
identifying to the blockchain that it is a staking transaction. The second 
VOUT will either contain an OP\_RETURN data transaction that contains a single 
public key, or it will contain a pay-to-pubkey script. The latter is usually 
used for simplicity but using a data transaction for this allows for some 
advanced use cases (such as a separate block signing machine) without 
needlessly cluttering the UTXO set.



Finally, any transactions from the mempool are added to the block. The only 
thing left to do now is to create a signature, proving that we have approved 
the otherwise valid PoS block. The signature must use the public key that is 
encoded (either as pay-pubkey script, or as a data OP\_RETURN script) in the 
second VOUT of the staking transaction. The actual data signed in the block 
hash. After the signature is applied, the block can be broadcast to the 
network. Nodes in the network will then validate the block and if it finds 
it valid and there is no better blockchain then it will accept it into its 
own blockchain and broadcast the block to all the nodes it has connection to.



It is highly recommended that you read the blog post by
‘\textit{Earlz}’\footnote{http://earlz.net/view/2017/07/27/1904/the-missing-explanation-of-proof-of-stake-version} 
and also the associated white papers for PoS33 and PoSv234 if you want to 
fully understand how Proof-of-Stake works. PoSv3 as described here also 
forms the basis of Proof-of-Anonymous-Stake that we will explore a bit 
further on.
